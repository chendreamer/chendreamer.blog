"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[5737],{6408:(e,r,a)=>{a.r(r),a.d(r,{data:()=>s});const s={key:"v-07ce8af2",path:"/server/npm&yarn.html",title:"npm&yarn",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"常用命令",slug:"常用命令",children:[]},{level:2,title:"package.json",slug:"package-json",children:[{level:3,title:"scripts",slug:"scripts",children:[]},{level:3,title:"require查找原理",slug:"require查找原理",children:[]}]},{level:2,title:"常见插件",slug:"常见插件",children:[{level:3,title:"cross-env",slug:"cross-env",children:[]}]}],filePathRelative:"server/npm&yarn.md",git:{updatedTime:1655460891e3,contributors:[]}}},3774:(e,r,a)=>{a.r(r),a.d(r,{default:()=>n});const s=(0,a(6252).uE)('<h1 id="npm-yarn" tabindex="-1"><a class="header-anchor" href="#npm-yarn" aria-hidden="true">#</a> npm&amp;yarn</h1><p><a href="https://www.npmjs.com/" target="_blank">npm官网，可以找npm插件</a></p><h2 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h2><h2 id="package-json" tabindex="-1"><a class="header-anchor" href="#package-json" aria-hidden="true">#</a> package.json</h2><h3 id="scripts" tabindex="-1"><a class="header-anchor" href="#scripts" aria-hidden="true">#</a> scripts</h3><p><a href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank">阮一峰日记参考</a><br> 原理：<br>   每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。<br>   比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。<br>   这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。</p><h3 id="require查找原理" tabindex="-1"><a class="header-anchor" href="#require查找原理" aria-hidden="true">#</a> require查找原理</h3><ul><li>假设有一个文件路径为 /root/src/moduleA.js，包含了一个导入</li></ul><p>var x = require(&quot;./moduleB&quot;); Node.js以下面的顺序解析这个导入：</p><ol><li>检查/root/src/moduleB.js文件是否存在。</li><li>检查/root/src/moduleB目录是否包含一个package.json文件，且package.json文件指定了一个&quot;main&quot;模块。 在我们的例子里，如果Node.js发现文件 /root/src/moduleB/package.json包含了{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }，那么Node.js会引用/root/src/moduleB/lib/mainModule.js。</li><li>检查/root/src/moduleB目录是否包含一个index.js文件。 这个文件会被隐式地当作那个文件夹下的&quot;main&quot;模块。</li></ol><ul><li>如果传给 require() 的模块标识符不是核心模块，并且不以 &#39;/&#39;、&#39;../&#39; 或 &#39;./&#39; 开头，则 Node.js 从当前模块的目录开始，并添加 /node_modules，并尝试从该位置加载模块。 Node.js 不会将 node_modules 附加到已经以 node_modules 结尾的路径。</li></ul><p>如果在那里找不到它，则它移动到父目录，依此类推，直到到达文件系统的根目录。</p><p>例如，如果 &#39;/home/ry/projects/foo.js&#39; 处的文件调用 require(&#39;bar.js&#39;)，则 Node.js 将按以下顺序查找以下位置：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/home/ry/projects/node_modules/bar.js\n/home/ry/node_modules/bar.js\n/home/node_modules/bar.js\n/node_modules/bar.js\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这允许程序本地化它们的依赖项，这样它们就不会发生冲突。</p><p>  通过在模块名称后包含路径后缀，可以要求与模块一起分发的特定文件或子模块。 例如，require(&#39;example-module/path/to/file&#39;) 将相对于 example-module 所在的位置解析 path/to/file。 后缀路径遵循相同的模块解析语义。</p><h2 id="常见插件" tabindex="-1"><a class="header-anchor" href="#常见插件" aria-hidden="true">#</a> 常见插件</h2><h3 id="cross-env" tabindex="-1"><a class="header-anchor" href="#cross-env" aria-hidden="true">#</a> cross-env</h3><p>cross-env能跨平台地设置及使用环境变量,只要在NODE_ENV前面加上cross-env标志，会根据当前系统类型帮你选择适当的指令给NODE_ENV赋值。<br> windows:<code>SET NODE_ENV=production &amp;&amp; webpack --config build/webpack.config.js</code><br> unix:<code>EXPORT NODE_ENV=production &amp;&amp; webpack --config build/webpack.config.js</code><br> cross-env:<code>cross-env NODE_ENV=production webpack --config build/webpack.config.js</code></p>',19),n={render:function(e,r){return s}}}}]);