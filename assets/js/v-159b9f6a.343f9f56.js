"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[833],{3158:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-159b9f6a",path:"/accumulation/js%E7%B1%BB.html",title:"JS类",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Ajax的原生写法",slug:"ajax的原生写法",children:[]},{level:2,title:"CommonJs,AMD, CMD, UMD",slug:"commonjs-amd-cmd-umd",children:[]},{level:2,title:"ctrl + cv时自定义文本",slug:"ctrl-cv时自定义文本",children:[]}],filePathRelative:"accumulation/js类.md",git:{updatedTime:1668654002e3,contributors:[]}}},3275:(n,e,s)=>{s.r(e),s.d(e,{default:()=>r});const a=(0,s(6252).uE)('<h1 id="js类" tabindex="-1"><a class="header-anchor" href="#js类" aria-hidden="true">#</a> JS类</h1><h2 id="ajax的原生写法" tabindex="-1"><a class="header-anchor" href="#ajax的原生写法" aria-hidden="true">#</a> Ajax的原生写法</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function ajax1() {\n    //创建一个 XHR 对象\n    let oAjax = window.XMLHttpRequest ? (new XMLHttpRequest()) : (new window.ActiveXobject(&#39;Microsoft.XMLHTTP&#39;));\n    //返回一个函数，这是函数柯里化操作，不用每次调用 ajax 都判断浏览器环境\n    //但是会占用更多的内存，因为总是会保存外部函数的作用域\n    return function(url, fnSucc, fnFaild) {\n        //只要 XHR 对象的 readyState 属性的值发生改变，就触发这个事件\n        oAjax.onreadystatechange = function() {\n        // readyState 属性是 0-4 的值，当为 4 时，表示已经接收到全部响应数据，并可以在客户端使用\n        if(oAjax.readyState === 4) {\n            //响应的 HTTP 状态\n            let s = oAjax.status;\n            if(s === 200 || s === 206 || s === 304) {\n            //将响应主体被返回的文本作为参数传给这个函数，并执行这个函数\n            if(fnSucc) fnSucc(oAjax.responseText);\n            }else {\n            if(fnFaild) fnFaild(oAjax.status);\n            }\n        }\n        };\n        //启动一个请求，准备发送\n        oAjax.open(&#39;GET&#39;, url, true);\n        //发送请求\n        oAjax.send(null);\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="commonjs-amd-cmd-umd" tabindex="-1"><a class="header-anchor" href="#commonjs-amd-cmd-umd" aria-hidden="true">#</a> CommonJs,AMD, CMD, UMD</h2><ul><li>CommonJS<br> node.js的模块系统，就是参照CommonJS规范实现的。</li><li>AMD<br> AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<br> 主要有两个Javascript库实现了AMD规范：require.js和curl.js。</li><li>CMD<br> CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。 AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。<br> AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</li><li>UMD<br> UMD是AMD和CommonJS的糅合。AMD模块以浏览器第一的原则发展，异步加载模块。CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。<br> UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</li></ul><h2 id="ctrl-cv时自定义文本" tabindex="-1"><a class="header-anchor" href="#ctrl-cv时自定义文本" aria-hidden="true">#</a> ctrl + cv时自定义文本</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//ctrl + c触发\ndocument.addEventListener(&#39;copy&#39;, function (oevent) {\n    //必须写，不然无法写入自定义文本\n    oevent.preventDefault();\n    var content = window.getSelection().toString();\n    content += &quot; powered by chenshuaiyu&quot;;\n    oevent.clipboardData.setData(&quot;text&quot;,content);\n})\n\n//ctrl + v触发\ndocument.addEventListener(&#39;paste&#39;, function (oevent) {\n    console.log(oevent.clipboardData.getData(&quot;text&quot;));\n})\n\ndocument.addEventListener(&#39;keyup&#39;, function(e) {\n    if(e.ctrlKey &amp;&amp; e.keyCode == &quot;67&quot;) {\n        var content = window.getSelection().toString();                    \n        alert(content)\n    }\n})\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div>',7),r={render:function(n,e){return a}}}}]);